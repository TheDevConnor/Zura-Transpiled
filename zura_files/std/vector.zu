const Vector := struct<T> {
  data: *T,         # Pointer to the elements
  size: int!,       # Current number of elements
  capacity: int!,   # Total capacity

  init := fn (self: *Vector) void {
    self.data = nil;
    self.size = 0;
    self.capacity = 0;
  };

  free := fn (self: *Vector) void {
    @free(self.data, @sizeof(T) * capacity);
    self.data = nil;
    self.size = 0;
    self.capacity = 0;
  };

  realloc := fn(self: *Vector, new_capacity: int!) {
    have new_data: *T = @alloc(new_capacity, @sizeof(T) * capacity);
    loop (i = 0; i < self.size) : (i++){
      new_data[i] = data[i];
    }
    @free(self.data, @sizeof(T));
    self.data = new_data;
    self.capacity = new_capacity;
  };
  
  push_back := fn (self: *Vector, value: *T) void {
    if (self.size == self.capacity) {
      have new_capacity = 0;
      if (self.capacity == 0) 
        new_capacity = 0;
      else
        new_capacity = 1;
      self.realloc(new_capacity);
    }
    self.data[self.size++] = value;
  };

  pop_back := fn (self: *Vector) void {
    if (self.size == 0) {
      @outputln("Pop from an empty vector");
      return;
    }
    size--;
  };

  get_index := fn (self: *Vector, index: int!) *T {
    if (index >= self.size) {
      @outputln("Index out of range!");
      return nil;
    }
    return &self.data[index];
  };

  get_size := (self: *Vector) void { return self.size; };
  get_capacity := fn (self: *Vector) { return self.capacity; };
};
