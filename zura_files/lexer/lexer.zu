@import "../std/asciiToString.zu";
@import "helper.zu";

const TokenKind := enum {
  Plus,
  Dash,
  Star,
  Slash,
  LParen,
  RParen,
  Number,
  Identifier,
  String,
  Comma,
  Semicolon,
  Equals,
  LBrace,
  RBrace,
  LBracket,
  RBracket,
  Less,
  Greater,
  Ampersand,
  Percent,
  Bang,
  Question,
  Colon,
  Dot
};

const Position := struct {
  line: int!,
  pos: int!
};

const Token := struct {
  kind: TokenKind,
  value: *char
};

# const make_token := fn (ln: *int!, col: *int!, k: TokenKind, v: *char) Token {
#   have pos: Position = { line: ln&, pos: col& };
#   have token: Token = {
#     position: pos,
#     kind: k,
#     value: v,
#   };
#   return token;
# };

const scan := fn (source: *char, size: int!) void {
  have whitespaceCount: int! = 0;
  have generate: bool! = true; # Flag to control token generation
  have col: int! = 0;
  have line: int! = 1;

  loop (i = 0; i < size) : (i++) {
    whitespaceCount = 0; # reset whitespace count for each character

    have whitespace: int! = check_whitespace(source, &i, &line, &col, size);
    if (whitespace == 1) {
      whitespaceCount++;
    } else {
      col++; # increment column count
    }

    have letter: int! = is_letter(source, &i);
    if (letter == 1) {
      @outputln(1, "Found a letter '", ascii_to_string(source[i]), "' at line: ", line, " col: ", col);
    }

    have digit: int! = is_digit(source[i]);
    if (digit == 1) {
      @outputln(1, "Found a digit '", ascii_to_string(source[i]), "' at line: ", line, " col: ", col);
    }

    # TODO: Implement check for single-character tokens and multi-character tokens
  }
};