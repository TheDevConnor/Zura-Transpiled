@import "../std/asciiToString.zu";

const TokenKind := enum {
  Plus,
  Dash,
  Star,
  Slash,
  LParen,
  RParen,
  Number,
  Identifier,
  String,
  Comma,
  Semicolon,
  Equals,
  LBrace,
  RBrace,
  LBracket,
  RBracket,
  Less,
  Greater,
  Ampersand,
  Percent,
  Bang,
  Question,
  Colon,
  Dot
};

const Position := struct {
  line: int!,
  pos: int!
};

const Token := struct {
  position: Position,
  kind: TokenKind,
  value: *char
};

# const make_token := fn (ln: int!, col: int!, k: TokenKind, v: *char) Token {
#   have pos: Position = { line: ln, pos: col };
#   have token: Token = {
#     position: pos,
#     kind: k,
#     value: v,
#   };
#   return token;
# };

const is_digit := fn (c: char) int {
  if (c >= @cast<char>(48)) { # '0'
    if (c <= @cast<char>(57)) { # '9'
      return 1; # true
    }
    return 0; # false
  }
  return 0; # false
};

const is_letter := fn (c: char) int {
  if (c >= @cast<char>(97)) { if (c <= @cast<char>(122)) return 1; } # a to z
  if (c >= @cast<char>(65)) { if (c <= @cast<char>(90)) return 1; } # A to Z
  if (c == @cast<char>(95)) return 1; # true
  return 0; # false
};

const scan := fn (source: *char, size: int!) void {
  have whitespaceCount: int! = 0;
  have generate: bool! = true; # Flag to control token generation
  have col: int! = 0;
  have line: int! = 1;

  loop (i = 0; i < size) : (i++) {
    whitespaceCount = 0; # reset whitespace count for each character

    # Check the whitespace [\n, \t, space]
    if (source[i] == @cast<char>(32)) { # space
      whitespaceCount++;
      col++; 
    }
    if (source[i] == @cast<char>(10)) { # newline
      whitespaceCount = 0;
      col = 0; # reset column count on newline
      line++; # increment line count
    } else {
      col++; # increment column count for non-whitespace characters
    }

    @outputln(0, "Character: ", ascii_to_string(source[i]), " (", source[i], ") at line: ", line, " col: ", col);
  }
};