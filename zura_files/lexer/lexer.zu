@import "../std/asciiToString.zu";
@import "helper.zu";

const tokenize := fn (source: *char, realSize: int!, tk: *[]Token) void {
  have line: int! = 1;
  have col: int! = 0;
  have value: *char = "";

  # !NOTE: Arrays are backwards in Zura; except when you are pushing to them like the tokens
  have keywords: [24]KeywordTable = [
    {text: "and", kind: @cast<int!>(TokenKind.And)},            {text: "else", kind: @cast<int!>(TokenKind.Else)},
    {text: "false", kind: @cast<int!>(TokenKind.False)},        {text: "fn", kind: @cast<int!>(TokenKind.Fn)},
    {text: "loop", kind: @cast<int!>(TokenKind.Loop)},          {text: "if", kind: @cast<int!>(TokenKind.If)},
    {text: "nil", kind: @cast<int!>(TokenKind.Nil)},            {text: "or", kind: @cast<int!>(TokenKind.Or)},
    {text: "true", kind: @cast<int!>(TokenKind.True)},          {text: "have", kind: @cast<int!>(TokenKind.Have)},          
    {text: "type", kind: @cast<int!>(TokenKind.Type)},          {text: "struct", kind: @cast<int!>(TokenKind.Struct)},      
    {text: "enum", kind: @cast<int!>(TokenKind.Enum)},          {text: "const", kind: @cast<int!>(TokenKind.Const)},        
    {text: "import", kind: @cast<int!>(TokenKind.Import)},      {text: "pub", kind: @cast<int!>(TokenKind.Pub)},            
    {text: "priv", kind: @cast<int!>(TokenKind.Priv)},          {text: "break", kind: @cast<int!>(TokenKind.Break)},        
    {text: "continue", kind: @cast<int!>(TokenKind.Continue)},  {text: "typename", kind: @cast<int!>(TokenKind.Typename)},  
    {text: "match", kind: @cast<int!>(TokenKind.Match)},        {text: "default", kind: @cast<int!>(TokenKind.Default)},    
    {text: "case", kind: @cast<int!>(TokenKind.Case)},          {text: "return", kind: @cast<int!>(TokenKind.Return)},
  ];

  have builtins: [26]BuiltinTable = [
    {text: "@template", kind: @cast<int!>(TokenKind.Template)},{text: "@cast", kind: @cast<int!>(TokenKind.Cast)},
    {text: "@import", kind: @cast<int!>(TokenKind.Import)},    {text: "@link", kind: @cast<int!>(TokenKind.Link)},
    {text: "@extern", kind: @cast<int!>(TokenKind.Extern)},    {text: "@call", kind: @cast<int!>(TokenKind.Call)},
    {text: "@output", kind: @cast<int!>(TokenKind.Output)},    {text: "@read", kind: @cast<int!>(TokenKind.Read)},
    {text: "@input", kind: @cast<int!>(TokenKind.Input)},      {text: "@write", kind: @cast<int!>(TokenKind.Write)},
    {text: "@free", kind: @cast<int!>(TokenKind.Free)},        {text: "@alloc", kind: @cast<int!>(TokenKind.Alloc)},
    {text: "@memcpy", kind: @cast<int!>(TokenKind.Memcpy)},    {text: "@sizeof", kind: @cast<int!>(TokenKind.Sizeof)},
    {text: "@getArgv", kind: @cast<int!>(TokenKind.GetArgv)},  {text: "@getArgc", kind: @cast<int!>(TokenKind.GetArgc)},
    {text: "@streq", kind: @cast<int!>(TokenKind.Streq)},      {text: "@open", kind: @cast<int!>(TokenKind.Open)},
    {text: "@close", kind: @cast<int!>(TokenKind.Close)},      {text: "@outputln", kind: @cast<int!>(TokenKind.Outputln)},
    {text: "@socket", kind: @cast<int!>(TokenKind.Socket)},    {text: "@bind", kind: @cast<int!>(TokenKind.Bind)},
    {text: "@listen", kind: @cast<int!>(TokenKind.Listen)},    {text: "@accept", kind: @cast<int!>(TokenKind.Accept)},
    {text: "@recv", kind: @cast<int!>(TokenKind.Recv)},        {text: "@send", kind: @cast<int!>(TokenKind.Send)}
  ];

  have symbol: [40]SymbolTable = [
    {text: "(", kind: @cast<int!>(TokenKind.LParen)},        {text: ")", kind: @cast<int!>(TokenKind.RParen)},
    {text: "{", kind: @cast<int!>(TokenKind.LBrace)},        {text: "}", kind: @cast<int!>(TokenKind.RBrace)},
    {text: ";", kind: @cast<int!>(TokenKind.Semicolon)},     {text: ",", kind: @cast<int!>(TokenKind.Comma)},
    {text: ".", kind: @cast<int!>(TokenKind.Dot)},           {text: "-", kind: @cast<int!>(TokenKind.Dash)},
    {text: "+", kind: @cast<int!>(TokenKind.Plus)},          {text: "/", kind: @cast<int!>(TokenKind.Slash)},
    {text: "*", kind: @cast<int!>(TokenKind.Star)},          {text: "%", kind: @cast<int!>(TokenKind.Percent)},
    {text: "^", kind: @cast<int!>(TokenKind.Caret)},         {text: "[", kind: @cast<int!>(TokenKind.LBracket)},
    {text: "]", kind: @cast<int!>(TokenKind.RBracket)},      {text: "?", kind: @cast<int!>(TokenKind.Question)},
    {text: ":", kind: @cast<int!>(TokenKind.Colon)},         {text: "=", kind: @cast<int!>(TokenKind.Equals)},
    {text: "!", kind: @cast<int!>(TokenKind.Bang)},          {text: "<", kind: @cast<int!>(TokenKind.Less)},
    {text: ">", kind: @cast<int!>(TokenKind.Greater)},       {text: "&", kind: @cast<int!>(TokenKind.Ampersand)},
    {text: "|", kind: @cast<int!>(TokenKind.LOr)},           {text: "!=", kind: @cast<int!>(TokenKind.BangEqual)},
    {text: "==", kind: @cast<int!>(TokenKind.EqualEqual)},   {text: ">=", kind: @cast<int!>(TokenKind.GreaterEqual)},
    {text: "<=", kind: @cast<int!>(TokenKind.LessEqual)},    {text: ":=", kind: @cast<int!>(TokenKind.Walrus)},
    {text: "++", kind: @cast<int!>(TokenKind.PlusPlus)},     {text: "--", kind: @cast<int!>(TokenKind.MinusMinus)},
    {text: "+=", kind: @cast<int!>(TokenKind.PlusEqual)},    {text: "-=", kind: @cast<int!>(TokenKind.MinusEqual)},
    {text: "*=", kind: @cast<int!>(TokenKind.StarEqual)},    {text: "/=", kind: @cast<int!>(TokenKind.SlashEqual)},
    {text: "&&", kind: @cast<int!>(TokenKind.And)},          {text: "||", kind: @cast<int!>(TokenKind.Or)},
    {text: "<-", kind: @cast<int!>(TokenKind.LeftArrow)},    {text: "->", kind: @cast<int!>(TokenKind.RightArrow)},
    {text: "..", kind: @cast<int!>(TokenKind.Range)},        {text: "::", kind: @cast<int!>(TokenKind.Resolution)},
  ];

  match_keyword("", keywords);
  match_builtin("", builtins);
  match_symbol("", symbol);

  loop (i = 0; i < realSize) : (i++) {
    # Check whitespace and skip it
    if (source[i] == @cast<char>(32)) { col++; } # Skip spaces
    if (source[i] == @cast<char>(10)) { line++; col = 0; } # Skip newlines

    if (is_eof(source, i)) break; # Stop at null terminator

    loop (j = i; alpha(source, &j)) : (j++) {
      tk&[j] = make_token(ascii_to_string(source[j]), @cast<int!>(TokenKind.Identifier), line, col);
      advance(&i, &col); # Advance past the letter
    }

    loop (j = i; digit(source, &j)) : (j++) {
      tk&[j] = make_token(ascii_to_string(source[j]), @cast<int!>(TokenKind.Int), line, col);
      advance(&i, &col); # Advance past the digit
    }

    tk&[i] = make_token(ascii_to_string(source[i]), 0, line, col);
  }

  # Add a null terminator to the end of the tokens array
  tk&[realSize] = make_token("", @cast<int!>(TokenKind.EOF), line, col + 1);
};