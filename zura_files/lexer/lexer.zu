@import "../std/asciiToString.zu";
@import "helper.zu";

const tokenize := fn (source: *char, realSize: int!, tk: *[]Token) void {
  have line: int! = 1;
  have col: int! = 0;
  have value: *char = "";

  # !NOTE: Arrays are backwards in Zura; except when you are pushing to them like the tokens
  # have keywords: [29]str = [
  #   "and", "else", "false", "fn", "loop", "if", "nil", "or", "exit",
  #   "super", "true", "have", "pkg", "in", "type", "struct", "enum",
  #   "union", "const", "import", "pub", "priv", "break", "continue",
  #   "typename", "match", "default", "case", "return"
  # ];

  # have at_keywords: [26]str = [
  #   "@template", "@cast", "@import", "@link", "@extern", "@call",
  #   "@output", "@read", "@input", "@write", "@free", "@alloc",
  #   "@memcpy", "@sizeof", "@getArgv", "@getArgc", "@streq",
  #   "@open", "@close", "@outputln", "@socket", "@bind",
  #   "@listen", "@accept", "@recv", "@send"
  # ];

  have symbol: [40]SymbolTable = [
    {text: "(", kind: @cast<int!>(TokenKind.LParen)},
    {text: ")", kind: @cast<int!>(TokenKind.RParen)},
    {text: "{", kind: @cast<int!>(TokenKind.LBrace)},
    {text: "}", kind: @cast<int!>(TokenKind.RBrace)},
    {text: ";", kind: @cast<int!>(TokenKind.Semicolon)},
    {text: ",", kind: @cast<int!>(TokenKind.Comma)},
    {text: ".", kind: @cast<int!>(TokenKind.Dot)},
    {text: "-", kind: @cast<int!>(TokenKind.Dash)},
    {text: "+", kind: @cast<int!>(TokenKind.Plus)},
    {text: "/", kind: @cast<int!>(TokenKind.Slash)},
    {text: "*", kind: @cast<int!>(TokenKind.Star)},
    {text: "%", kind: @cast<int!>(TokenKind.Percent)},
    {text: "^", kind: @cast<int!>(TokenKind.Caret)},
    {text: "[", kind: @cast<int!>(TokenKind.LBracket)},
    {text: "]", kind: @cast<int!>(TokenKind.RBracket)},
    {text: "?", kind: @cast<int!>(TokenKind.Question)},
    {text: ":", kind: @cast<int!>(TokenKind.Colon)},
    {text: "=", kind: @cast<int!>(TokenKind.Equals)},
    {text: "!", kind: @cast<int!>(TokenKind.Bang)},
    {text: "<", kind: @cast<int!>(TokenKind.Less)},
    {text: ">", kind: @cast<int!>(TokenKind.Greater)},
    {text: "&", kind: @cast<int!>(TokenKind.Ampersand)},
    {text: "|", kind: @cast<int!>(TokenKind.LOr)},
    {text: "!=", kind: @cast<int!>(TokenKind.BangEqual)},
    {text: "==", kind: @cast<int!>(TokenKind.EqualEqual)},
    {text: ">=", kind: @cast<int!>(TokenKind.GreaterEqual)},
    {text: "<=", kind: @cast<int!>(TokenKind.LessEqual)},
    {text: ":=", kind: @cast<int!>(TokenKind.Walrus)},
    {text: "++", kind: @cast<int!>(TokenKind.PlusPlus)},
    {text: "--", kind: @cast<int!>(TokenKind.MinusMinus)},
    {text: "+=", kind: @cast<int!>(TokenKind.PlusEqual)},
    {text: "-=", kind: @cast<int!>(TokenKind.MinusEqual)},
    {text: "*=", kind: @cast<int!>(TokenKind.StarEqual)},
    {text: "/=", kind: @cast<int!>(TokenKind.SlashEqual)},
    {text: "&&", kind: @cast<int!>(TokenKind.And)},
    {text: "||", kind: @cast<int!>(TokenKind.Or)},
    {text: "<-", kind: @cast<int!>(TokenKind.LeftArrow)},
    {text: "->", kind: @cast<int!>(TokenKind.RightArrow)},
    {text: "..", kind: @cast<int!>(TokenKind.Range)},
    {text: "::", kind: @cast<int!>(TokenKind.Resolution)},
  ];

  loop (i = 0; i < realSize) : (i++) {
    # Check whitespace and skip it
    if (source[i] == @cast<char>(32)) { col++; } # Skip spaces
    if (source[i] == @cast<char>(10)) { line++; col = 0; } # Skip newlines

    if (is_eof(source, i)) break; # Stop at null terminator

    loop (j = i; alpha(source, &j)) : (j++) {
      tk&[j] = make_token(ascii_to_string(source[j]), @cast<int!>(TokenKind.Identifier), line, col);
      advance(&i, &col); # Advance past the letter
    }

    loop (j = i; digit(source, &j)) : (j++) {
      tk&[j] = make_token(ascii_to_string(source[j]), @cast<int!>(TokenKind.Int), line, col);
      advance(&i, &col); # Advance past the digit
    }

    tk&[i] = make_token(ascii_to_string(source[i]), 0, line, col);
  }

  # Add a null terminator to the end of the tokens array
  tk&[realSize] = make_token("", @cast<int!>(TokenKind.EOF), line, col + 1);
};