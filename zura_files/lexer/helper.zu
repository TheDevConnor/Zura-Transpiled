@import "../std/type.zu";

const TokenKind := enum {
  # Literals
  Char,
  Bool,
  Nil,
  Int,
  Float,
  Identifier,
  String,

  # Operators
  Plus,
  Dash,
  Star,
  Slash,
  LParen,
  RParen,
  Comma,
  Semicolon,
  Equals,
  LBrace,
  RBrace,
  LBracket,
  RBracket,
  Less,
  Greater,
  Ampersand,
  Percent,
  Bang,
  Question,
  Colon,
  Dot,
  Caret,
  LAnd,
  LOr,
  BangEqual,
  EqualEqual,
  GreaterEqual,
  LessEqual,
  Walrus,
  PlusPlus,
  MinusMinus,
  PlusEqual,
  MinusEqual,
  StarEqual,
  SlashEqual,
  And,
  Or,
  LeftArrow,
  RightArrow,
  AndAnd,
  OrOr,
  Increment,
  Decrement,

  # Keywords 
  Else,
  False,
  Fn,
  Loop,
  If,
  Or,
  Exit,
  True,
  Have,
  Pkg,
  In,
  Type,
  Struct,
  Enum,
  Const,
  Import,
  Pub,
  Priv,
  Break,
  Continue,
  Typename,
  Match,
  Default,
  Case,
  Return,

  # Built-in functions
  Template,
  Cast,
  Import,
  Link,
  Extern,
  Call,
  Output,
  Read,
  Input,
  Write,
  Free,
  Alloc,
  Memcpy,
  Sizeof,
  GetArgv,
  GetArgc,
  Streq,
  Open,
  Close,
  Outputln,
  Socket,
  Bind,
  Listen,
  Accept,
  Recv,
  Send,

  EOF
};

const Token := struct {
  value: str,
  kind: int!,
  line: int!,
  col: int!,
};

const SingleSymbolTable := struct {
  text: char,
  kind: int!
};

const DoubleSymbolTable := struct {
  text: str,
  kind: int!
};

const KeywordTable := struct {
  text: str,
  kind: int!
};

const BuiltinTable := struct {
  text: str,
  kind: int!
};

const is_eof := fn (source: *char, index: int!) bool {
  if (source[index] == @cast<char>(0)) return true;
  return false;
};

const advance := fn (index: *int!, col: *int!) void {
  index&++;
  col&++;
};

const make_token := fn (value: str, kind: int!, line: int!, col: int!) Token {
  have token: Token = {
    value: value,
    kind: kind,
    line: line,
    col: col,
  };
  return token;
};

const match_keyword := fn (v: *char, keywords: *[]KeywordTable, 
                           tks: *[]Token, index: *int!) int? {
  loop (i = 0; i < 24) : (i++) {
    @outputln(1, keywords&[i].text);
  }
  return -1; # Not found
};

const match_builtin := fn (v: *char, builtins: *[]BuiltinTable, 
                           tks: *[]Token, index: *int!) int? {
  loop (i = 0; i < 26) : (i++) {
    @outputln(1, builtins&[i].text);
  }
  return -1; # Not found
};

const match_ssymbol := fn (v: char, symbols: *[]SingleSymbolTable, 
                           tks: *[]Token, index: *int!) int? {
  loop (i = 0; i < 23) : (i++) {
    @outputln(1, ascii_to_string(symbols&[i].text));
  }
  return -1; # Not found
};

const match_dsymbol := fn (v: char, symbols: *[]DoubleSymbolTable, 
                           tks: *[]Token, index: *int!) int? {
  loop (i = 0; i < 11) : (i++) {
    @outputln(1, symbols&[i].text);
  }
  return -1; # Not found
};
