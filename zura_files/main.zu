const ERRORS := enum {
  InvlaidArgument,
  OutputError,
  NoArgumentsProvided,
  NoPathProvided,
  NoActionProvided,
};

const readFile := fn (path: *char) *char {
  have numBytes: int! = 2048; # 2048 is VERY few character but allow this to be changed later, maybe implement paging???  
  have bytes: *char = @cast<*char>(@alloc(numBytes));
  have fd: int! = @open(path, true, false, false);

  if (fd < 0) {
    @outputln(1, "ERROR: Could not open file: ", path);
    @free(bytes, numBytes);
    return nil; # Return nil if the file could not be opened
  }

  @input(fd, bytes, numBytes);
  @close(fd);
  return bytes;
};

const main := fn () int! {
  have argv: *[]str = @getArgv();
  have argc: int! = @getArgc();

  if (argc < 2) {
    @outputln(1, "No arguments provided. Please provide a string to reverse.");
    return ERRORS.NoArgumentsProvided; # 2
  }

  have filePath: *char = nil;
  loop (i = 0; i < argc) :  (i++) {
    if (@strcmp(argv&[i], "build")) {
      # expect the very next argument to be a path, if there IS a next argument
      if (i == argc - 1) {
        @outputln(1, "ERROR: No filepath to build.");
        return ERRORS.NoPathProvided; # 3
      }

      # That means that there IS a next argument! Yippee!
      i++;
      @outputln(1, "Building file: ", argv&[i]); # Should be a path to a file
      filePath = @cast<*char>(argv&[i]);
      # THe loop will increase it again and we can skip this argument en
    }
  }

  if (filePath == nil) {
    # you cant read a null file right??
    return ERRORS.NoActionProvided;
  }

  have fileContents: *char = readFile(filePath);

  @output(1, fileContents); # i am tweaking its so cold

  @free(fileContents, 2048);
  return 0;
};