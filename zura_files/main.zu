const ERRORS := enum {
  InvlaidArgument,     # 0
  OutputError,         # 1
  NoArgumentsProvided, # 2
  NoPathProvided,      # 3
  NoActionProvided,    # 4
  FileOpenFailed,      # 5
};

const readFile := fn (path: *char) *char {
  have numBytes: int! = 2048; # 2048 is VERY few character but allow this to be changed later, maybe implement paging???  
  have bytes: *char = @cast<*char>(@alloc(numBytes));
  have fd: int! = @open(path, true, false, false);

  if (fd < 0) {
    @free(bytes, numBytes);
    return nil; # Return nil if the file could not be opened
  }

  @input(fd, bytes, numBytes);
  @close(fd);
  return bytes;
};

const main := fn () int! {
  have argv: *[]str = @getArgv();
  have argc: int! = @getArgc();

  if (argc < 2) {
    @outputln(1, "No arguments provided. Please provide a string to reverse.");
    return ERRORS.NoArgumentsProvided; # 2
  }

  have filePath: *char = nil;
  loop (i = 0; i < argc) :  (i++) {
    if (@strcmp(argv&[i], "build")) {
      # expect the very next argument to be a path, if there IS a next argument
      if (i == argc - 1) {
        @outputln(1, "ERROR: No filepath to build.");
        return ERRORS.NoPathProvided; # 3
      }

      # That means that there IS a next argument! Yippee!
      i++;
      @outputln(1, "Building file: ", argv&[i]); # Should be a path to a file
      filePath = @cast<*char>(argv&[i]);
      # THe loop will increase it again and we can skip this argument en
    }
  }

  if (filePath == nil) {
    # you cant read a null file right??
    return ERRORS.NoActionProvided; # 4
  }

  have fileContents: *char = readFile(filePath);

  if (fileContents == nil) {
    @outputln(1, "ERROR: Could not open file: ", filePath);
    return ERRORS.FileOpenFailed; # 5
  }

  @output(1, fileContents);

  @free(fileContents, 2048);
  return 0;
};